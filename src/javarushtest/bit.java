package javarushtest;

public class bit {

    public static void main(String[] args) {

        int x = 342;
        System.out.println(Integer.toBinaryString(x));
        System.out.println(~x);//Он работает очень просто: проходится по каждому биту нашего числа, и меняет его значение на противоположное: нули — на единицы, единицы на нули.
        System.out.println(277&432);//Далее оператор & сравнивает первый бит верхнего числа с первым битом нижнего. Поскольку это оператор “И”, то результат будет равен 1 только в том случае, если оба бита равны 1. Во всех остальных случаях результатом будет 0.
        System.out.println(277|432);//| — побитовое “ИЛИ”. Принцип работы тот же самый — сравниваем два числа по битам. Только теперь если хотя бы один из битов равен 1 — то результат будет равен 1.
        System.out.println(277^432);//^ — побитовое исключающее “ИЛИ” (также известно как XOR) Если истинны оба операнда — обычное “или” вернет true(“хотя бы один истинный“), а вот исключающее или вернет false. Поэтому он и называется исключающим.

        int p = 64;//значение
        int y = 3;//количество
        //БИТОВЫЕ СДВИГИ.
        int z = (p << y);//Сдвиг влево - Сдвиг битов влево обозначается знаком <<
        System.out.println(Integer.toBinaryString(p));
        System.out.println(Integer.toBinaryString(z));//512
        //При каждом сдвиге влево выполняется умножение числа на 2.!!!!!!!!!!!!!
        System.out.println(5 << 6); //- (как 6 раз умножить на 2
        int d = (p >> y);//Сдвиги вправо
        //При каждом сдвиге вправо выполняется деление на два с отбрасыванием любого остатка.!!!!!!!!!!!!!
        //Итого, 35 >> 2 должно быть равно 8.
        //При сдвиге вправо >>, если число отрицательное, пустое пространство заполняется 1, а не нулями. Например 0001 >> 3 == 1110001 (этот пример приведен исключительно, ради наглядности).
        // И не было сказано про >>> - побитовый сдвиг вправо с заполнением 0, вне зависимости от знака числа)
    }
}